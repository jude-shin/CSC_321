\documentclass[11pt]{article}

\usepackage{graphicx}
\usepackage{framed}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{subcaption}

\marginparwidth 0.5in 
\oddsidemargin 0.25in 
\evensidemargin 0.25in 
\marginparsep 0.25in
\topmargin 0.25in 
\textwidth 6in \textheight 8 in

\lstset{
  backgroundcolor=\color{backcolor}, % Set background color
  commentstyle=\color{codegreen}, % Style for comments
  keywordstyle=\color{magenta}, % Style for keywords
  numberstyle=\tiny\color{codegray}, % Style for line numbers
  stringstyle=\color{codepurple}, % Style for strings
  basicstyle=\ttfamily\footnotesize, % Basic font style and size
  breakatwhitespace=false, % Don't break lines at whitespace only
  breaklines=true, % Enable line breaking
  captionpos=b, % Caption position (bottom)
  keepspaces=true, % Keep spaces
  numbers=left, % Show line numbers on the left
  numbersep=5pt, % Separation of numbers from code
  showspaces=false, % Don't show spaces as visible characters
  showstringspaces=false, % Don't show spaces in strings
  showtabs=false, % Don't show tabs as visible characters
  tabsize=2, % Tab size
  language=Python % Specify the language
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolor}{rgb}{0.95,0.95,0.95}

\begin{document}
\hfill\vbox{\hbox{Jude Shin, Torrey Zachs}
		\hbox{CSC 321, Section 07}	
		\hbox{Module 3: Public Key}	
		\hbox{\today}}\par

\bigskip
\centerline{\Large\bf Lab 03: Public Key Cryptography Implementation}\par
\bigskip

This lab explores public key cryptography security with both Diffie-Hellman Key Exchange Protocol and the RSA encryption scheme. This lab was completed using {\tt Python} and {\tt PyCryptodome}. All the code can be found in our remote \href{https://github.com/jude-shin/CSC\_321}{GitHub} repository.

% ============================================================================
\section*{Environment}

If you want to run and test the code, a virtual environment should first be set up with the correct requirements. This ensures that there is consistency between all of the packages used within this project.

\begin{itemize}
	\item Make a virtual environment (venv) with Python.
		\verb|$ python3 -m venv .venv|
	\item Activate the venv.
		\verb|$ source .venv/bin/activate|
	\item Install the requirements using pip.
		\verb|$ pip install -r requirements.txt|
	\item Whenever you are done, you can deactivate the venv.
		\verb|$ deactivate|
\end{itemize}

\subsection*{Reproduction}

Running any of the code is as simple as activating the venv and then running the python script.

\verb|(.venv) python task3.py|

% ============================================================================
\section*{Task 1: Diffie-Hellman Key Exchange}

\subsection*{Abstract}

The code was a hard coded series of steps that first outlined the exchange of a secret using Diffie Hellman Key Exchange. Then the secret was known to Alice and Bob. The secret was then used in a SHA256 to create a digest of 16 bytes. This allowed us to implement the AES-CBC encryption algorithm to send secret messages of arbitrary length (the implementation is not shown for AES-CBC. Refer to Module 2). We can’t directly use Diffie Hellman to encrypt large messages because the output is of a fixed length. The given q and a were used as IETF suggested values for 1024-bits.

\subsection*{Code}

\begin{lstlisting}
import sys

from cbc.cbc import encrypt_cbc, decrypt_cbc
from dataclasses import dataclass

from Crypto.Hash import SHA256
import secrets

BLOCK_SIZE: int = 16

# helper to pad text bytes with pkcs#7 padding
def add_padding(text: bytes, block_size: int) -> bytes:
    # Get the remainder that is needed to become a multiple of block_size
    k: int = block_size - len(text)%block_size

    # k(byte) will be repeated k times
    single_byte: bytes = k.to_bytes(1, 'big')
    padding: bytes = single_byte * k

    # Append the padding to the end of the text 
    return text + padding 

@dataclass 
class Participant:
    q: int                              #large prime number
    alpha: int                          #primitive root mod q
    myPrivateValue: int = None          #X_A or X_B
    myPublicValue: int = None           #Y_A or Y_B
    otherPublicValue: int = None        #Y_B or Y_A
    secretValue: int = None             #s
    secretKey: bytes =None              #k. Computed with SHA

    def generate_private(self):
        self.myPrivateValue = secrets.randbelow(self.q - 1) + 1  # 1 <= X < q

    def compute_public(self):
        self.myPublicValue = pow(self.alpha, self.myPrivateValue, self.q)    # Y = alpha^X mod q

    def givePublicValue(self, y: int):
        self.otherPublicValue = y

    def compute_secret_key(self):
        self.secretValue = pow(self.otherPublicValue, self.myPrivateValue, self.q)       # s = Y_other^X mod q

        hash_key = self.secretValue  # the shared secret int
        hash_bytes = hash_key.to_bytes((hash_key.bit_length()+7)//8 or 1, 'big')
        hash_obj = SHA256.new(hash_bytes)
        self.secretKey = hash_obj.digest()[:BLOCK_SIZE]  #use SHA digest as key, truncate to 16 bytes for AES-128
    
    def recv_message(self, encrypted_message: bytes):
        randomIV = encrypted_message[:BLOCK_SIZE]
        ciphertext = encrypted_message[BLOCK_SIZE:]

        decrypted_message = decrypt_cbc(ciphertext, self.secretKey, randomIV)

        print(f"Decrypted message: {decrypted_message.decode('utf-8')}")

    #send message using our secert key, and a random iv at start of msg in plaintext
    def send_message(self, message: bytes, otherParticipant: "Participant"):
        # Encrypt the message using AES with the shared secret key
        randomIV = secrets.token_bytes(BLOCK_SIZE)
        padded_message: bytes = add_padding(message, BLOCK_SIZE)
        encrypted_message = randomIV + encrypt_cbc(padded_message, self.secretKey, randomIV)

        otherParticipant.recv_message(encrypted_message)


if __name__ == '__main__':
    q = 0xB10B8F96A080E01DDE92DE5EAE5D54EC52C99FBCFB06A3C69A6A9
		DCA52D23B616073E28675A23D189838EF1E2EE652C013ECB4AEA9061123
		24975C3CD49B83BFACCBDD7D90C4BD7098488E9C219A73724EFFD6FAE56
		44738FAA31A4FF55BCCC0A151AF5F0DC8B4BD45BF37DF365C1A65E68CFD
		A76D4DA708DF1FB2BC2E4A4371

    alpha = 0xA4D1CBD5C3FD34126765A442EFB99905F8104DD258AC507FD
		6406CFF14266D31266FEA1E5C41564B777E690F5504F213160217B4B01B
		886A5E91547F9E2749F4D7FBD7D3B9A92EE1909D0D2263F80A76A6A24C0
		87A091F531DBF0A0169B6A28AD662A4D18E73AFA32D779D5918D08BC885
		8F4DCEF97C2A24855E6EEB22B3B2E5

    Alice = Participant(q, alpha)
    Bob = Participant(q, alpha)

    Alice.generate_private()
    Alice.compute_public()

    Bob.generate_private()
    Bob.compute_public()

    #they exchange Y_A and Y_B
    Bob.givePublicValue(Alice.myPublicValue)
    Alice.givePublicValue(Bob.myPublicValue)

    Alice.compute_secret_key()
    Bob.compute_secret_key()

    Alice.send_message(b"Hello Bob!", Bob)
    Bob.send_message(b"Hello Alice!", Alice)
\end{lstlisting}


% ============================================================================
\section*{Task 2: MITM key fixing \& negotiated groups}

\subsection*{Case 1: Abstract}

All good things must come to an end. The Diffie Hellman Key Exchange seems like it is perfect for all scenarios, however, there is a big downside to this. In this scenario, Trudy is an attacker trying to exploit this. Publicly known values q and a are shared amongst everyone (including Trudy). Alice is going to compute her Y\_A value (public) and try to send it over to Bob. Before it gets to Bob, Trudy keeps it for herself, and sends Bob q instead. The same is done for when Bob calculates his public value and tries to send it to Alice. When it comes time to create the secret key from the public y values, they will end up getting a value that was canceled out (0). Trudy knows that the values were canceled out, resulting in a secret that Alice and Bob believe to be unique and secret, but was manipulated by simple math. Note that [q raised to the power of anything] mod q will produce 0.

When Alice and Bob go to use their favorite encryption algorithm, Trudy will be able to decrypt all of their messages because she knows that the key they are using is 0. 

\subsection*{Case 1: Code}

\begin{lstlisting}
def task2Case_1(q: int, alpha: int):
    print("Task 2, Case 1: Trudy intercepts and replaces public keys with q")

    Alice = Participant(q, alpha)
    Bob = Participant(q, alpha)
    Trudy = Participant(q, alpha)   # will immitate Alice to Bob

    Alice.generate_private()
    Alice.compute_public()

    Bob.generate_private()
    Bob.compute_public()

    #Trudy intercepts and replaces public keys with q
    Bob.givePublicValue(Trudy.q)
    Alice.givePublicValue(Trudy.q)  

    # Trudy knows the key will be computed using 0 as the secret value
    k_trudy = SHA256.new(b'\x00').digest()[:BLOCK_SIZE] 
    Trudy.set_secret_key(k_trudy)

    #they no longer exchange Y_A and Y_B
    # Bob.givePublicValue(Alice.myPublicValue)
    # Alice.givePublicValue(Bob.myPublicValue)

    Alice.compute_secret_key()
    Bob.compute_secret_key()

    Alice.send_message(b"Hello Bob!", Bob)
    Bob.send_message(b"Hello Alice!", Alice)

    print("\nTrudy can decrypt these messages too:")
    #Trudy, listening in on these messages, can now decrypt them as well
    Alice.send_message(b"Hello Bob #2!", Trudy)
    Bob.send_message(b"Hello Alice #2!", Trudy)

\end{lstlisting}

\subsection*{Case 2: Abstract}

There are known values for a to create weak secrets when using the Diffie Hellman Key Exchange. When a = 1, a raised to the power of anything will always be 1. When a = q, the secret will end up being 0 as well, given that there is still the modulo operation done with q (similar to the exploit in case 1). Finally, when a = q-1, the resulting secret will become an alternating series of 1 and q-1. 

Again, when Alice and Bob go to use their favorite encryption algorithm, Trudy will be able to decrypt all of their messages because she would know the key they are using, as she set up the public values to make the secret somewhat predictable. 

\subsection*{Case 2: Code}
\begin{lstlisting}
def task2Case_2(q: int, intercepted_alpha: int):
    if(intercepted_alpha not in [1, q-1, q]):
        print("Error: intercepted_alpha must be 1, q-1, or q")
        return
    
    #based on what alpha we want to use, Trudy can determine possible secret values
    possible_secretValues = [1] # if intercepted_alpha == 1
    alphaString = "1"
    if(intercepted_alpha == q):
        possible_secretValues = [0]
        alphaString = "q"
    elif(intercepted_alpha == q-1):
        possible_secretValues = [1, q-1]
        alphaString = "q-1"

    #compute possible secret keys based on possible secret values
    possible_secretKeys = []
    for sv in possible_secretValues:
        hash_key = sv  # the shared secret int
        hash_bytes = hash_key.to_bytes((hash_key.bit_length()+7)//8 or 1, 'big')
        hash_obj = SHA256.new(hash_bytes)
        possible_secretKeys.append(hash_obj.digest()[:BLOCK_SIZE])  #use SHA digest as key, truncate to 16 bytes for AES-128
    #

    #simulation where intercepted alpha is used, and Trudy tries all possible secret keys based on intercepted_alpha
    print("Task 2, Case 2: Trudy modifies alpha = " + alphaString)
    Alice = Participant(q, intercepted_alpha)
    Bob = Participant(q, intercepted_alpha)
    Trudy = Participant(q, intercepted_alpha, intruder = True)   # will immitate Alice to Bob

    Alice.generate_private()
    Alice.compute_public()

    Bob.generate_private()
    Bob.compute_public()

    # Trudy knows what the keys will look like
    Trudy.set_secret_key(possible_secretKeys)

    #Bob and Alice exchance public keys
    Bob.givePublicValue(Alice.myPublicValue)
    Alice.givePublicValue(Bob.myPublicValue)

    Alice.compute_secret_key()
    Bob.compute_secret_key()

    Alice.send_message(b"Hello Bob!", Bob)
    Bob.send_message(b"Hello Alice!", Alice)

    print("\nTrudy can decrypt these messages too:")
    #Trudy, listening in on these messages, can now decrypt them as well
    Alice.send_message(b"Hello Bob #2!", Trudy)
    Bob.send_message(b"Hello Alice #2!", Trudy)
\end{lstlisting}

\subsection*{Code: Main Function Running Everything}

\begin{lstlisting}
if __name__ == '__main__':
    q = 0xB10B8F96A080E01DDE92DE5EAE5D54EC52C99FBCFB06A3C69A6A9
		DCA52D23B616073E28675A23D189838EF1E2EE652C013ECB4AEA9061123
		24975C3CD49B83BFACCBDD7D90C4BD7098488E9C219A73724EFFD6FAE56
		44738FAA31A4FF55BCCC0A151AF5F0DC8B4BD45BF37DF365C1A65E68CFD
		A76D4DA708DF1FB2BC2E4A4371

    alpha = 0xA4D1CBD5C3FD34126765A442EFB99905F8104DD258AC507FD
		6406CFF14266D31266FEA1E5C41564B777E690F5504F213160217B4B01B
		886A5E91547F9E2749F4D7FBD7D3B9A92EE1909D0D2263F80A76A6A24C0
		87A091F531DBF0A0169B6A28AD662A4D18E73AFA32D779D5918D08BC885
		8F4DCEF97C2A24855E6EEB22B3B2E5

    #Trudy replaces public keys with q
    task2Case_1(q, alpha)

    #Trudy modifies alpha to be 1, q-1, or q
    print("\n")
    alpha = 1
    task2Case_2(q, alpha)
    print("\n")
    alpha = q - 1
    task2Case_2(q, alpha)
    print("\n")
    alpha = q   
    task2Case_2(q, alpha)
\end{lstlisting}


% ============================================================================
\section*{Task 3: ``Textbook'' RSA \& MITM Key Fixing via Malleability}
\subsection*{Case 1: Abstract}

Implementation of RSA was relatively straightforward. Alice and Bob create their key pair by picking 2 large primes that are not equal. They them compute an euler totient function on the product of those two primes. Finally, they compute the modulo inverse of an e that is relatively prime to e. The public key pair is (e, n) where e is the result of the totient funciton, and n is the product of the two primes. The private key pair is (d, n), where d is the modulo inverse. For encryption, you take an INTEGER (could be text converted to hex, or a secret), raise it to the power of e, and then take the mod of n.  To reverse it, take the ciphertext, raise it to the power of d, and then modulo against d. Note that RSA is slow, weak, and the message cannot be larger than the key. 

\subsection*{Case 2: Abstract}
One of RSA’s great weaknesses is its malleability; an active attacker can change the meaning of the plaintext message by performing an operation on the respective ciphertext.

\subsection*{Code Breakdown}

\begin{lstlisting}
def gen_primes_for_rsa(numBits, e):
    k = numBits >> 1
    p = number.getStrongPrime(k, e=e)
    q = number.getStrongPrime(k, e=e)
    while p == q:
        q = number.getStrongPrime(k, e=e)
    assert gcd(e, p-1) == 1 and gcd(e, q-1) == 1
    return p, q

# helper to pad text bytes with pkcs#7 padding
def add_padding(text: bytes, block_size: int) -> bytes:
    # Get the remainder that is needed to become a multiple of block_size
    k: int = block_size - len(text)%block_size

    # k(byte) will be repeated k times
    single_byte: bytes = k.to_bytes(1, 'big')
    padding: bytes = single_byte * k

    # Append the padding to the end of the text 
    return text + padding 

@dataclass
class ParticipantRSA:
    #declared at startup
    numBits: int = 2048
    e: int = 65537
    p: int = None
    q: int = None
    n: int = None
    totient_of_n: int = None

    # recv from peer, this info is public
    peer_n: int = None
    peer_e: int = None

    # computed with peer info
    d: int = None

    #key that gets computed by sending RSA header
    secretKey: bytes = None

    # generate RSA stuff
    def generate_keys(self): 
        self.p, self.q = gen_primes_for_rsa(self.numBits, self.e)
        self.n = self.p * self.q
        self.totient_of_n = lcm(self.p - 1, self.q - 1)
        self.d = pow(self.e, -1, self.totient_of_n)  # private exponent
    
    #exchange public values (e and n)
    def set_peer_public(self, n: int, e: int = 65537):
        self.peer_n = n
        self.peer_e = e

    # --- RSA key transport (one-time or whenever you want to rotate) ---
    def send_key(self, other: "ParticipantRSA"):
        sym = secrets.token_bytes(16)
        self.secretKey = SHA256.new(sym).digest()[:16]   # hash before storing
        m = int.from_bytes(sym, 'big')
        c = pow(m, self.peer_e, self.peer_n)            #
        rsa_ct = c.to_bytes((self.peer_n.bit_length()+7)//8, 'big')
        other.recv_key(rsa_ct)

    def recv_key(self, rsa_ct: bytes):
        c = int.from_bytes(rsa_ct, 'big')
        m = pow(c, self.d, self.n)
        k_bytes = m.to_bytes((m.bit_length()+7)//8 or 1, 'big')  # minimal big-endian
        # if len(k_bytes) < BLOCK_SIZE:
        #     k = k.rjust(BLOCK_SIZE, b'\x00')
        self.secretKey = SHA256.new(k_bytes).digest()[:BLOCK_SIZE] 

    # --- AES-CBC messaging (exact style from your Task 2) ---
    def send_message(self, message: bytes, other: "ParticipantRSA"):
        randomIV = secrets.token_bytes(BLOCK_SIZE)
        padded_message = add_padding(message, BLOCK_SIZE)   # your helper
        encrypted_message = randomIV + encrypt_cbc(padded_message, self.secretKey, randomIV)
        other.recv_message(encrypted_message)

    def recv_message(self, encrypted_message: bytes):
        randomIV = encrypted_message[:BLOCK_SIZE]
        ciphertext = encrypted_message[BLOCK_SIZE:]
        decrypted_message = decrypt_cbc(ciphertext, self.secretKey, randomIV)
        print(f"Decrypted message: {decrypted_message.decode('utf-8')}")

    # Stuff for Trudy (attacker) to manipulate RSA
    def prepare_cprime_for_known_k(self, recipient_n: int, recipient_e: int, k_bytes: bytes):
        # x := k_bytes  (attacker-chosen preimage)
        x_int = int.from_bytes(k_bytes, 'big')
        cprime_int = pow(x_int, recipient_e, recipient_n)           # c' = x^e mod n
        self.cprime = cprime_int.to_bytes((recipient_n.bit_length()+7)//8, 'big')
        self.secretKey = SHA256.new(k_bytes).digest()[:BLOCK_SIZE]  # k = H(x)

    def prepare_cprime_one(self, recipient_n: int):
        # x := 0x01
        self.cprime = (1).to_bytes((recipient_n.bit_length()+7)//8, 'big')
        self.secretKey = SHA256.new(b'\x01').digest()[:BLOCK_SIZE]  # k = H(0x01)
    

def part1_basic_rsa_test():
    # Alice and Bob setup
    Alice = ParticipantRSA(numBits=2048, e=65537)
    Bob   = ParticipantRSA(numBits=2048, e=65537)

    # keygen
    Alice.generate_keys()
    Bob.generate_keys()

    # exchange public info (n,e)
    Alice.set_peer_public(Bob.n, Bob.e)
    Bob.set_peer_public(Alice.n, Alice.e)

    # Exchange symmetric keys via RSA
    Alice.send_key(Bob)   
    Bob.send_key(Alice)   

    # test that these keys are legit, and we can send messages
    Alice.send_message(b"Hello Bob (sent using RSA generated key)", Bob)
    Bob.send_message(b"Hello Alice (sent using RSA generated key)", Alice)

def part2_trudy_replaces_with_one():
    Alice = ParticipantRSA()
    Bob   = ParticipantRSA()
    Trudy = ParticipantRSA()

    Alice.generate_keys()
    Bob.generate_keys()
    Trudy.generate_keys()

    Bob.set_peer_public(Alice.n, Alice.e)
    Trudy.prepare_cprime_one(Alice.n)
    Alice.recv_key(Trudy.cprime)
    Alice.send_message(b"Hello Bob (intercepted by Trudy by injecting c')", Trudy)

#This is another example of how RSA's maleability could be exploited (not explicitly asked for). This is much worse than the "replace with 1" attack
#Not only can Trudy see the messages being sent, she can now also send her own messages to Alice and Bob, pretending to be legitimate
def part2_trudy_forces_k():
    Alice = ParticipantRSA()
    Bob   = ParticipantRSA()
    Trudy = ParticipantRSA()

    Alice.generate_keys()
    Bob.generate_keys()
    Trudy.generate_keys()

    Bob.set_peer_public(Alice.n, Alice.e)   # Bob wants to talk to Alice, but never does

    #Trudy creates a completely arbitrary k, and injects a c' that will cause Alice to derive that k
    #Trudy can then decrypt any messages Alice sends to Bob, since she knows k
    chosen_k = secrets.token_bytes(BLOCK_SIZE)
    Trudy.prepare_cprime_for_known_k(Alice.n, Alice.e, chosen_k)
    Alice.recv_key(Trudy.cprime)
    Alice.send_message(b"Hello Bob (intercepted by Trudy by forcing k and injecting c')", Trudy)
    Trudy.send_message(b"Hello Alice, Im Bob, (total lies, this is really Trudy)", Alice)


def part2_malleability_demo():
    Alice = ParticipantRSA()
    Alice.generate_keys()
    m1 = 12345678901234567890 % Alice.n
    m2 = 9876543210987654321 % Alice.n
    sig1 = pow(m1, Alice.d, Alice.n)
    sig2 = pow(m2, Alice.d, Alice.n)
    sig3 = (sig1 * sig2) % Alice.n
    m3 = (m1 * m2) % Alice.n
    print ("observed signature 1: " + str(sig1) + "\nobserved signature 2: " + str(sig2) + "\ngenerated signature, also valid: " + str(sig3) + "\nthis signature is valid for message: " + str(m3))
    print("sig3 OK:", pow(sig3, Alice.e, Alice.n) == m3)

if __name__ == "__main__":
    #shows 1) from task 3
    print("basic RSA test")
    part1_basic_rsa_test()
    print("\ntrudy replaces c' 1 demo")
    part2_trudy_replaces_with_one()
    print("\ntrudy can just create a key, and inject c'. demo (example of another maleability attack, not specified in assignment)")
    part2_trudy_forces_k()
    print("\nmaleability demo")
    part2_malleability_demo()
\end{lstlisting}


% ============================================================================
\section*{Questions}
\subsection*{Question 1}

The numbers provided for q and a are relatively small. The recommended bit size is nothing less than 2048 (task one uses 1024-bit values). This is considered very weak for today's standards; on top of that, there are also still other active techniques like man-in-the-middle attacks would compromise the Diffie Hellman Key Exchange.

\subsection*{Question 2}

Yes, encryption of a key from a q value of 37 and alpha value of 5 will work for the Diffie Hellman Key Exchange. The only prerequisite for those values is that q must be prime (preferably a large number), and alpha must be a primitive root of q. a is a primitive root of q if every number in the set \{1, 2, 3, ... q-2, q-1\} ca be generated by raising a to some power modulo q.

\subsection*{Question 3}

Diffie Hellman is not secure against active attacks like the man in the middle. This occured because each party communicating could not verify that they were talking to the real person (Alice did not know she was actually talking to Mallory; she thought she was really talking to Bob). Bob and Alice could establish some form of authentication beforehand, but that defeats the purpose of being able to share secrets without ever meeting. The integrity could also be verified through trusted sources like public key certificates.

\subsection*{Question 4}

Suppose Alice and Bob both share the same \verb|n|, but have different \verb|e|’s. Also, assume that both \verb|e|’s are coprime. The chance of two random integers being coprime is around 60\%, so this is very likely. Also, both \verb|e|'s are sent publicly, so it will be easy for an attacker to check if \verb|e1| and \verb|e2| are coprime. Also, \verb|n| is sent at the start of the messaging, so we can assume the attacker knows what \verb|n| is and will easily recognize if two people have the same \verb|n|.

In short, an attacker assumes Alice and Bob share \verb|n|, Alice and Bob have different \verb|e|’s that are coprime.

Alice and Bob send the same message (call it \verb|m|), we can imagine this being pretty common if two users are using the same protocol, and both, for example, send “Hello” on startup.

Alice and Bob encrypt the message using their shared \verb|n| but different \verb|e| values. Let \verb|e1| be Alice’s \verb|e|, and \verb|e2| be Bob’s \verb|e|. Note that Alice and Bob send their \verb|e1| and \verb|e2| publicly at the start of messaging.

The ciphertexts (\verb|c1| for Alice) and (\verb|c2| for Bob) of the messages that get sent are

\begin{verbatim}
c1 = (m^e1) mod n 
c2 = (m^e2) mod n
\end{verbatim}

The attacker can observe these two ciphertexts as they are sent over the network.
since we assume \verb|e1| and \verb|e2| are coprime, i.e. \verb|gcd(e1, e2) = 1|. by Euclid's extended algorithm, 
One can compute \verb|s| and \verb|t| such that:

\begin{verbatim}
s e1 + t e2 = 1
\end{verbatim}

Equipped with these \verb|s| and \verb|t|’s, since \verb|s| \verb|e1 + t e2 = 1| it follows that:
\begin{verbatim}
c1^s + c2^t = (m^e1)^s + (m^e2)^t = m^(s e1 + t e2) = m^1 = m
\end{verbatim}

So by computing \verb|c1^s| + \verb|c2^t|, the attacker has computed the message that Bob and Alice just sent back and forth!

\end{document}
